{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SUMMIT Documentation Quick start Setting up SUMMIT Loading and spawning maps Using roads and sidewalks Simulating traffic Building from source Building SUMMIT Advanced topics Preparing maps Python API reference","title":"Home"},{"location":"getting_started/building/","text":"Important Building SUMMIT is only necessary if you wish to edit SUMMIT. If you only wish to use the simulator, the setup steps are sufficient. Building SUMMIT The build instructions for SUMMIT are exactly the same as those in CARLA. To build SUMMIT, follow exactly the build instructions for CARLA , with some additional steps: Clone and use the SUMMIT repository instead of the CARLA repository. Before building , install ccache : sudo apt install ccache . After getting assets , copy the following SUMMIT specific assets into the assets folder, overriding any existing files: Copy <summit_root>/CustomAssets/EmptyMap.umap to <summit_root>/Unreal/CarlaUE4/Content/Carla/Maps/TestMaps/EmptyMap.umap Copy <summit_root>/CustomAssets/EmptyMap_BuiltData.umap to <summit_root>/Unreal/CarlaUE4/Content/Carla/Maps/TestMaps/EmptyMap_BuiltData.umap Copy <summit_root>/CustomAssets/M_Tile.uasset to <summit_root>/Unreal/CarlaUE4/Content/Carla/Static/GenericMaterials/Ground/M_Tile.uasset","title":"Building SUMMIT"},{"location":"getting_started/introduction/","text":"SUMMIT SUMMIT ( S imulator for U rban Driving i n M assive Mi xed T raffic) is an open-source simulator with a focus on generating high-fidelity, interactive data for unregulated, dense urban traffic on complex real-world maps. It works with map data in the form of OSM files and SUMO networks to generate crowds of heterogeneous traffic agents with sophisticated and realistic unregulated behaviors. SUMMIT can work with map data fetched from online sources, providing a virtually unlimited source of complex environments. SUMMIT additionally exposes interfaces to interact with the contextual information provided by the map data. It also provides a robust suite of geometric utilities for use by external programs. Through these, SUMMIT aims to enablie applications in a wide range of fields such as perception, vehicle control and planning, end-to-end learning, etc. SUMMIT was built upon the very successful CARLA . Updates to CARLA are constantly merged into SUMMIT to ensure that users of SUMMIT have access to the high quality of work endowed by CARLA, such as its high-fidelity physics, rendering and sensors; however, it should be noted that not all components of SUMMIT work with those from CARLA, as they were designed for a different use case. The simulator SUMMIT adds on top of CARLA a set of capabilities to enable the simulation of sophisticated traffic behaviors on real-world maps: Road contexts: In SUMMIT, the SumoNetwork interface is exposed to allow for easy interaction with roads, which are represented using SUMO networks . It is optimized for fast spatial and topological queries. Sidewalk contexts: Sidewalks are represented using a collection of oriented polygons with holes. SUMMIT exposes the Sidewalk interface to easily interact with sidewalks. It is optimized for fast spatial and topological queries. Sidewalks are automatically generated as boundaries along roads. Geometric utilities: SUMMIT provides a range of utility classes to help with various geometric operations. OccupancyMap : Manipulation for general 2D areas. Useful for exact collision detection. AABBMap : Manipulation for axis aligned bounding boxes. Useful for fast approximate collision detection. SegmentsMap : Maipulation for collections of 2D line segments. Primarily used to sample high quality uniformly distributed spawn points on roads and sidewalks. Procedural simulation: Spawning a scenario is entirely procedural, and no recompilation the simulator is required for simulation on a new map. Mesh information for map objects such as roads, sidewalks, landmarks, and satellite imagery are sent from the client to the simulation server, where the objects are dynamically spawned. Crowd simulator: SUMMIT provides a client side Python script that simulates unregulated traffic in the simulation. It is capable of generating dense crowds, involving vehicles on the road and pedestrians on the sidewalk, where agents operate interactively with one another. GAMMA , a state-of-the-art traffic motion prediction model, is used to produce sophisticated and realistic behaviors in the simulated crowd.","title":"Introduction"},{"location":"getting_started/introduction/#summit","text":"SUMMIT ( S imulator for U rban Driving i n M assive Mi xed T raffic) is an open-source simulator with a focus on generating high-fidelity, interactive data for unregulated, dense urban traffic on complex real-world maps. It works with map data in the form of OSM files and SUMO networks to generate crowds of heterogeneous traffic agents with sophisticated and realistic unregulated behaviors. SUMMIT can work with map data fetched from online sources, providing a virtually unlimited source of complex environments. SUMMIT additionally exposes interfaces to interact with the contextual information provided by the map data. It also provides a robust suite of geometric utilities for use by external programs. Through these, SUMMIT aims to enablie applications in a wide range of fields such as perception, vehicle control and planning, end-to-end learning, etc. SUMMIT was built upon the very successful CARLA . Updates to CARLA are constantly merged into SUMMIT to ensure that users of SUMMIT have access to the high quality of work endowed by CARLA, such as its high-fidelity physics, rendering and sensors; however, it should be noted that not all components of SUMMIT work with those from CARLA, as they were designed for a different use case.","title":"SUMMIT"},{"location":"getting_started/introduction/#the-simulator","text":"SUMMIT adds on top of CARLA a set of capabilities to enable the simulation of sophisticated traffic behaviors on real-world maps: Road contexts: In SUMMIT, the SumoNetwork interface is exposed to allow for easy interaction with roads, which are represented using SUMO networks . It is optimized for fast spatial and topological queries. Sidewalk contexts: Sidewalks are represented using a collection of oriented polygons with holes. SUMMIT exposes the Sidewalk interface to easily interact with sidewalks. It is optimized for fast spatial and topological queries. Sidewalks are automatically generated as boundaries along roads. Geometric utilities: SUMMIT provides a range of utility classes to help with various geometric operations. OccupancyMap : Manipulation for general 2D areas. Useful for exact collision detection. AABBMap : Manipulation for axis aligned bounding boxes. Useful for fast approximate collision detection. SegmentsMap : Maipulation for collections of 2D line segments. Primarily used to sample high quality uniformly distributed spawn points on roads and sidewalks. Procedural simulation: Spawning a scenario is entirely procedural, and no recompilation the simulator is required for simulation on a new map. Mesh information for map objects such as roads, sidewalks, landmarks, and satellite imagery are sent from the client to the simulation server, where the objects are dynamically spawned. Crowd simulator: SUMMIT provides a client side Python script that simulates unregulated traffic in the simulation. It is capable of generating dense crowds, involving vehicles on the road and pedestrians on the sidewalk, where agents operate interactively with one another. GAMMA , a state-of-the-art traffic motion prediction model, is used to produce sophisticated and realistic behaviors in the simulated crowd.","title":"The simulator"},{"location":"getting_started/setting_up/","text":"Setting up SUMMIT Requirements The requirements from SUMMIT derive from those of CARLA. Please ensure that you have met the requirements of CARLA in order to use SUMMIT. Important (As an exception, SUMMIT only supports Linux , and we do not have any foreseeable plans to extend support for Windows or macOS) In addition, we make use of a few additional packages, as listed below. Python 2 packages: pip2 install --user pathlib2 Pyro4 Python 3 packages: pip3 install --user pathlib Pyro4 (Optional) JOSM : A set of tools to edit to downloaded OSM files. Highly recommended if you intend to use your own maps. If so, we recommend that you familiarize yourself with JOSM's usage. (Optional) SUMO tools : A set of tools to convert OSM files into SUMO networks, and to edit SUMO networks. Highly recommended if you intend to use your own maps. If so, we also recommend that you familiarize yourself with the usage of SUMO's tools, in particular NETCONVERT and NETEDIT . Downloading SUMMIT Running SUMMIT Open a terminal in the folder where SUMMIT was extracted, and run ./CarleUE4.sh to start the simulator. A window will open, containing an empty map. The simulator is now running as a server, waiting for client apps to connect and to interact (e.g. spawning map objects dynamically, simulating a crowd, etc.) with it. To move around, use the mouse and WASD keys (while clicking).","title":"Setting up SUMMIT"},{"location":"getting_started/setting_up/#requirements","text":"The requirements from SUMMIT derive from those of CARLA. Please ensure that you have met the requirements of CARLA in order to use SUMMIT. Important (As an exception, SUMMIT only supports Linux , and we do not have any foreseeable plans to extend support for Windows or macOS) In addition, we make use of a few additional packages, as listed below. Python 2 packages: pip2 install --user pathlib2 Pyro4 Python 3 packages: pip3 install --user pathlib Pyro4 (Optional) JOSM : A set of tools to edit to downloaded OSM files. Highly recommended if you intend to use your own maps. If so, we recommend that you familiarize yourself with JOSM's usage. (Optional) SUMO tools : A set of tools to convert OSM files into SUMO networks, and to edit SUMO networks. Highly recommended if you intend to use your own maps. If so, we also recommend that you familiarize yourself with the usage of SUMO's tools, in particular NETCONVERT and NETEDIT .","title":"Requirements"},{"location":"getting_started/setting_up/#downloading-summit","text":"","title":"Downloading SUMMIT"},{"location":"getting_started/setting_up/#running-summit","text":"Open a terminal in the folder where SUMMIT was extracted, and run ./CarleUE4.sh to start the simulator. A window will open, containing an empty map. The simulator is now running as a server, waiting for client apps to connect and to interact (e.g. spawning map objects dynamically, simulating a crowd, etc.) with it. To move around, use the mouse and WASD keys (while clicking).","title":"Running SUMMIT"},{"location":"references/python_api/","text":"Important SUMMIT's Python API is an extension of CARLA's Python API . All classes and methods appearing in CARLA's Python API are accessible in SUMMIT. However, since some components were designed for different use cases, not all components from CARLA may work with SUMMIT components, and vice versa. carla.Actor Only additional features introduced in SUMMIT to carla.Actor are listed here. Please refer to CARLA's implementation for the remaining original features, all of which are also accessible. Methods set_collision_enabled ( self , enabled ) Enable or disable collision for this instance. Parameters: enabled : bool carla.AABB2D 2D axis aligned bounding box helper class. Instance Variables bounds_min ( carla.Vector2D ) bounds_max ( carla.Vector2D ) Methods __eq__ ( self , other ) Parameters: other ( carla.AABB2D ) __ne__ ( self , other ) Parameters: other ( carla.AABB2D ) carla.AABBMap Data structure optimized for efficient collision checking of 2D axis aligned bounding boxes (AABBs). Methods __init__ ( self ) Constructs an empty instance. __len__ ( self ) Returns the number of AABBs contained in this instance. insert ( self , aabb ) Inserts an AABB into this instance. Parameters: aabb ( carla.AABB2D ) intersects ( self , aabb ) Checks if an AABB intersects with any contained in this instance. Parameters: aabb ( carla.AABB2D ) Return: bool carla.Landmark Helper class to load landmark meshes from OSM files. load ( filename , offset =carla.Vector2D(0, 0) ) Loads all landmark meshes from an OSM file, applying an optional offset. Parameters: filename ( str ) offset ( carla.Vector2D ) Return: list( carla.OccupancyMap ) carla.OccupancyMap Data structure to manipulate 2D areas of occupancy. Instance Variables is_empty ( bool ) Returns whether this instance represents an empty area. Methods __init__ ( self ) Constructs an instance representing an empty area. __init__ ( self , line , width ) Constructs an instance representing a line buffered by some width. Parameters: line ( list( carla.Vector2D ) ) width ( float ) Note: The buffered line has a width of width . Its ends are also approximately buffered round with a diameter of width . __init__ ( self , polygon ) Constructs an instance representing a closed polygon. Parameters: polygon ( list( carla.Vector2D ) ) Note: Polygon vertices can be given in any orientation. Additionally, the last vertex should not be repeated. An n-gon will require only each of the n vertices. load ( self , filename ) Saves this instance to a file. Parameters: filename ( str ) load ( filename ) Loads an instance from a file. Parameters: filename ( str ) union ( self , other ) Returns the union of this instance's area and that of another instance. Parameters: other ( carla.OccupancyMap ) Return: carla.OccupancyMap difference ( self , other ) Returns the difference of this instance's area and that of another instance. Parameters: other ( carla.OccupancyMap ) Return: carla.OccupancyMap Note: The difference returned is the area covered by this instance that is not covered by the other instance. intersection ( self , other ) Returns the intersection of this instance's area and that of another instance. Parameters: other ( carla.OccupancyMap ) Return: carla.OccupancyMap buffer ( self , width ) Returns the area formed by buffering the outlines of this instance's area by some width. Parameters: width ( float ) Return: carla.OccupancyMap Note: The buffered lines have a width of width . Ends are also approximately buffered round with a diameter of width . intersects ( self , other ) Checks if this instance's area intersects that of another instance. Parameters: other ( carla.OccupancyMap ) Return: bool contains ( self , point ) Checks if a point is contained in this instance's area. Parameters: point ( carla.Vector2D ) Return: bool create_sidewalk ( self , distance ) Creates a sidewalk along the outlines of this instance's area, with some distance away from the outlines. Parameters: distance ( float ) Return: carla.Sidewalk get_triangles ( self ) Returns the triangles in the triangulation of this instance's area. Return: list( carla.Triangle2D ) get_mesh_triangles ( self , offset =0.0 ) Returns the triangles, arranged in a list of 3D vertices, in the triangulation of this instance's area with some optional added height offset. Parameters: offset ( float ) Return: list( carla.Vector3D ) Note: Both upward and downward facing triangles are produced. get_wall_mesh_triangles ( self , height =0.0 ) Returns the triangles, arranged in a list of 3D vertices, in the triangulation of the area formed by sweeping this instance's area vertically by some height. Parameters: height ( float ) Return: list( carla.Vector3D ) Note: Both inward and outward facing triangles are produced. carla.Segment2D 2D line segment helper class. Instance Variables start ( carla.Vector2D ) end ( carla.Vector2D ) Methods __eq__ ( self , other ) Parameters: other ( carla.Segment2D ) __ne__ ( self , other ) Parameters: other ( carla.Segment2D ) carla.SegmentMap Represents a collection of line segments. Mainly used for efficiently sampling uniformly from collections of line segments. Methods __init__ ( self , segments ) Constructs an instance from a collection of line segments. Parameters: segments ( list( carla.Segment2D ) ) get_segments ( self ) Returns a list of all segments stored in this instance. Return: list( carla.Segment2D ) Note: This operation can be time-consuming, as each segment is converted from an internal representation into a carla.Segment2D . seed_rand ( self , seed ) Resets this instance's internal random number generator with a seed value. Parameters: seed ( int ) rand_point ( self ) Sample a random point uniformly from this instance's segments. Return: carla.Vector2D Note: Firstly, a line segment is sampled with probability proportional to its length. Then, a point is uniformly picked along the selected line segment. union ( self , other ) Returns a union of this instance's segments and that of another instance. Parameters: other ( carla.SegmentMap ) Return: carla.SegmentMap difference ( self , other ) Returns the difference of this instance's segments and an occupancy map's area. Parameters: other ( carla.OccupancyMap ) Return: carla.SegmentMap Note: The difference returned are the segments covered by this instance, cut appropriately, that are not contained in the occupancy maps' area. intersection ( self , other ) Returns the intersection of this instance's segments and an occupancy map's area. Parameters: other ( carla.OccupancyMap ) Return: carla.SegmentMap carla.Sidewalk Represents a sidewalk. Methods get_route_point_position ( self , route_point ) Converts a sidewalk route point into the corresponding actual position. Parameters: route_point ( carla.SidewalkRoutePoint ) Return: carla.Vector2D get_nearest_route_point ( self , position ) Determines the sidewalk route point closest to a position. Parameters: position ( carla.Vector2D ) Return: carla.SidewalkRoutePoint get_next_route_point ( self , route_point , distance ) Gets the next route point succeeding some route point by some distance. Parameters: route_point ( carla.SidewalkRoutePoint ) distance ( float ) Return: carla.SidewalkRoutePoint Note: The returned route point is ahead of the given route point anticlockwise along the route point's polygon. get_previous_route_point ( self , route_point , distance ) Gets the next route point preceding some route point by some distance. Parameters: route_point ( carla.SidewalkRoutePoint ) distance ( float ) Return: carla.SidewalkRoutePoint Note: The returned route point is ahead of the given route point clockwise along the route point's polygon. create_occupancy_map ( self , width ) Creates an occupancy map by buffering the paths in this instance by some width. Parameters: width ( float ) Return: carla.OccupancyMap Note: The buffered lines have a width of width . Ends are also approximately buffered round with a diameter of width . create_segment_map ( self ) Creates a carla.SegmentMap using the paths found in this instance. Return: carla.SegmentMap intersects ( self , segment ) Checks if a line segment intersects with the paths in this instance. Parameters: segment ( carla.Segment2D ) Return: bool carla.SidewalkRoutePoint Represents a sidewalk route point. Instance Variables polygon_id ( int ) segment_id ( int ) offset ( float ) Methods __init__ ( self ) carla.SumoNetwork Represents a SUMO network. Instance Variables bounds_min ( carla.Vector2D ) Gets the minimum point of this instance's bounds. bounds_max ( carla.Vector2D ) Gets the maximum point of this instance's bounds. original_bounds_min ( carla.Vector2D ) Gets the minimum point (in LatLon) of this instance's geographic bounds. original_bounds_max ( carla.Vector2D ) Gets the maximum point (in LatLon) of this instance's geographic bounds. offset ( carla.Vector2D ) Gets the offset applied to the SUMO network to move it to the origin. Methods get_route_point_position ( self , route_point ) Converts a SUMO network route point into the corresponding actual position. Parameters: route_point ( carla.SumoNetworkRoutePoint ) Return: carla.Vector2D get_nearest_route_point ( self , position ) Determines the SUMO network route point closest to a position. Parameters: position ( carla.Vector2D ) Return: carla.SumoNetworkRoutePoint get_next_route_points ( self , route_point , distance ) Gets the list of possible next route points succeeding some route point by some distance. Parameters: route_point ( carla.SumoNetworkRoutePoint ) distance ( float ) Return: list( carla.SumoNetworkRoutePoint ) get_next_route_paths ( self , route_point , num_points , interval ) Gets the list of possible paths succeeding some route point. Each path spans a specified number of points with some given interval. Parameters: route_point ( carla.SumoNetworkRoutePoint ) num_points ( int ) interval ( float ) Return: list(list( carla.SumoNetworkRoutePoint )) create_occupancy_map ( self ) Creates the occupancy map for this instance. Return: carla.OccupancyMap create_roadmark_occupancy_map ( self ) Creates the occupancy map for this instance's roadmarks. Return: carla.OccupancyMap create_segment_map ( self ) Creates a carla.SegmentMap using the lanes found in this instance. Return: carla.SegmentMap carla.SumoNetworkRoutePoint Represents a SUMO network route point. Instance Variables edge ( str ) lane ( int ) segment ( int ) offset ( float ) Methods __init__ ( self ) carla.Triangle2D 2D triangle helper class. Instance Variables v0 ( carla.Vector2D ) v1 ( carla.Vector2D ) v2 ( carla.Vector2D ) Methods __eq__ ( self , other ) Parameters: other ( carla.Triangle2D ) __ne__ ( self , other ) Parameters: other ( carla.Triangle2D ) carla.Vector2D Only additional features introduced in SUMMIT to carla.Vector2D are listed here. Please refer to CARLA's implementation for the remaining original features, all of which are also accessible. Methods squared_length ( self ) Returns the squared length of this instance. Return: float length ( self ) Returns the length of this instance. Return: float make_unit_vector ( self ) Returns the unit vector of this instance. Return: carla.Vector2D rotate ( self , angle ) Returns the result of rotating this instance by an angle. Parameters: angle : ( float ) (in radians) Return: carla.Vector2D dot_product ( vector1 , vector2 ) Returns the dot product of two vectors. Parameters: vector1 : ( carla.Vector2D ) vector2 : ( carla.Vector2D ) Return: float carla.World Only additional features introduced in SUMMIT to carla.World are listed here. Please refer to CARLA's implementation for the remaining original features, all of which are also accessible. Methods spawn_dynamic_mesh ( self , triangles , material , segmentation_tag ) Spawns a dynamic mesh using mesh triangles, together with a specified material and segmentation tag . Returns the id of the spawned dynamic mesh (note: these ids are not the same as actor ids). Parameters: triangles : list( carla.Vector3D ) material : str segmentation_tag : int Return: int spawn_dynamic_tile_mesh ( self , bounds_min , bounds_max , data , segmentation_tag ) Spawns a rectangular dynamic mesh of a JPEG image segmentation tag . Returns the id of the spawned dynamic mesh (note: these ids are not the same as actor ids). Parameters: bounds_min : carla.Vector3D bounds_max : carla.Vector3D data : list(int) - The JPEG data, as an array of bytes. segmentation_tag : int Return: int destroy_dynamic_mesh ( self , id ) Destroys a dynamic mesh given its id. Returns whether the operation succeeded. Parameters: id : int Return: bool command.SpawnDynamicMesh Spawns a dynamic mesh out of mesh triangles. Instance Variables triangles ( list( carla.Triangle2D ) ) material ( str ) semantic_tag ( int ) Methods __init__ ( triangles , material , segmentation_tag ) Parameters: triangles : list( carla.Vector3D ) material : str segmentation_tag : int command.DestroyDynamicMesh Destroys a dynamic mesh given its id. Instance Variables id ( int ) Methods __init__ ( id ) Parameters: id : int","title":"Python API reference"},{"location":"references/python_api/#carlaactor","text":"Only additional features introduced in SUMMIT to carla.Actor are listed here. Please refer to CARLA's implementation for the remaining original features, all of which are also accessible.","title":"carla.Actor"},{"location":"references/python_api/#carlaaabb2d","text":"2D axis aligned bounding box helper class.","title":"carla.AABB2D"},{"location":"references/python_api/#carlaaabbmap","text":"Data structure optimized for efficient collision checking of 2D axis aligned bounding boxes (AABBs).","title":"carla.AABBMap"},{"location":"references/python_api/#carlalandmark","text":"Helper class to load landmark meshes from OSM files. load ( filename , offset =carla.Vector2D(0, 0) ) Loads all landmark meshes from an OSM file, applying an optional offset. Parameters: filename ( str ) offset ( carla.Vector2D ) Return: list( carla.OccupancyMap )","title":"carla.Landmark"},{"location":"references/python_api/#carlaoccupancymap","text":"Data structure to manipulate 2D areas of occupancy.","title":"carla.OccupancyMap"},{"location":"references/python_api/#carlasegment2d","text":"2D line segment helper class.","title":"carla.Segment2D"},{"location":"references/python_api/#carlasegmentmap","text":"Represents a collection of line segments. Mainly used for efficiently sampling uniformly from collections of line segments.","title":"carla.SegmentMap"},{"location":"references/python_api/#carlasidewalk","text":"Represents a sidewalk.","title":"carla.Sidewalk"},{"location":"references/python_api/#carlasidewalkroutepoint","text":"Represents a sidewalk route point.","title":"carla.SidewalkRoutePoint"},{"location":"references/python_api/#carlasumonetwork","text":"Represents a SUMO network.","title":"carla.SumoNetwork"},{"location":"references/python_api/#carlasumonetworkroutepoint","text":"Represents a SUMO network route point.","title":"carla.SumoNetworkRoutePoint"},{"location":"references/python_api/#carlatriangle2d","text":"2D triangle helper class.","title":"carla.Triangle2D"},{"location":"references/python_api/#carlavector2d","text":"Only additional features introduced in SUMMIT to carla.Vector2D are listed here. Please refer to CARLA's implementation for the remaining original features, all of which are also accessible.","title":"carla.Vector2D"},{"location":"references/python_api/#carlaworld","text":"Only additional features introduced in SUMMIT to carla.World are listed here. Please refer to CARLA's implementation for the remaining original features, all of which are also accessible.","title":"carla.World"},{"location":"references/python_api/#commandspawndynamicmesh","text":"Spawns a dynamic mesh out of mesh triangles.","title":"command.SpawnDynamicMesh"},{"location":"references/python_api/#commanddestroydynamicmesh","text":"Destroys a dynamic mesh given its id.","title":"command.DestroyDynamicMesh"},{"location":"references/summit_map_library/","text":"SUMMIT Map Library This page lists all available maps built into SUMMIT that are ready for use. These maps are all extracted from real locations in the world. beijing Identifier: beijing Type: Highway Location: Chao Yang Men Bei Da Jie. Beijing, China chandni_chowk Identifier: chandni_chowk Description: Roundabout Location: Bhai Mati Das Chowk. New Delhi, India highway Identifier: highway Type: Highway Location: Ayer Rajah Expressway. Singapore magic Identifier: magic Type: Roundabout Location: The Magic Roundabout. Swindon, United Kingdom meskel_square Identifier: meskel_square Type: Intersection Location: Meskel Square. Addis Ababa, Ethiopia shi_men_er_lu Identifier: shi_men_er_lu Type: Intersection Location: Shi Men Er Lu. Shanghai, China shibuya Identifier: shibuya Type: Intersection Location: Shibuya Crossing. Tokyo, Japan","title":"SUMMIT map library"},{"location":"references/summit_map_library/#beijing","text":"Identifier: beijing Type: Highway Location: Chao Yang Men Bei Da Jie. Beijing, China","title":"beijing"},{"location":"references/summit_map_library/#chandni_chowk","text":"Identifier: chandni_chowk Description: Roundabout Location: Bhai Mati Das Chowk. New Delhi, India","title":"chandni_chowk"},{"location":"references/summit_map_library/#highway","text":"Identifier: highway Type: Highway Location: Ayer Rajah Expressway. Singapore","title":"highway"},{"location":"references/summit_map_library/#magic","text":"Identifier: magic Type: Roundabout Location: The Magic Roundabout. Swindon, United Kingdom","title":"magic"},{"location":"references/summit_map_library/#meskel_square","text":"Identifier: meskel_square Type: Intersection Location: Meskel Square. Addis Ababa, Ethiopia","title":"meskel_square"},{"location":"references/summit_map_library/#shi_men_er_lu","text":"Identifier: shi_men_er_lu Type: Intersection Location: Shi Men Er Lu. Shanghai, China","title":"shi_men_er_lu"},{"location":"references/summit_map_library/#shibuya","text":"Identifier: shibuya Type: Intersection Location: Shibuya Crossing. Tokyo, Japan","title":"shibuya"},{"location":"tutorials/loading_and_spawning_maps/","text":"Important SUMMIT comes with scripts that spawn all relevant map objects covered in this tutorial. You may use it directly them <summit_root>/PythonAPI/examples/spawn_meshes.py and <summit_root>/PythonAPI/examples/spawn_imagery.py , without going through this tutorial. Note that these scripts require that you have already cached the map object meshes and downloaded the satellite imagery . For built-in SUMMIT maps, these have already been done for you, so you may go ahead with using the scripts directly, skipping this tutorial. Connecting to the simulator The steps to connect to the simulator derives from CARLA . A client object is created from which the world is received: client = carla.Client('localhost', 2000) world = client.get_world() Roads and roadmarks Roads are represented using SUMO networks, which are loaded into memory via a SUMO network file: sumo_network = carla.SumoNetwork.load(PATH_TO_SUMO_NETWORK_FILE) The occupancy map (i.e. mesh) for the road can be produced by calling: sumo_network_occupancy = sumo_network.create_occupancy_map() If you required roadmarks (e.g. lane dividers), SUMMIT provides a fully automated way to generate the roadmarks' mesh: roadmark_occupancy = sumo_network.create_roadmark_occupancy_map() The road and roadmarks' meshes are then sent to the simulator and spawned dynamically: # Get mesh triangles, and defines material and segmentation tag for road. # Roadmarks' mesh is subtracted from the road's mesh to prevent flickering due to overlaps. road_triangles = sumo_network_occupancy.difference(roadmark_occupancy).get_mesh_triangles() road_material = '/Game/Carla/Static/GenericMaterials/Masters/LowComplexity/M_Road1' road_segmentation = 7 # Road (defined by CARLA). # Get mesh triangles, and defines material and segmentation tag for roadmarks. roadmark_triangles = roadmark_occupancy.get_mesh_triangles() roadmark_material = '/Game/Carla/Static/GenericMaterials/LaneMarking/M_MarkingLane_W' roadmark_segmentation = 6 # Road line (defined by CARLA). # Spawn road and roadmarks dynamically in simulator. world.spawn_dynamic_mesh(road_triangles, road_material, road_segmentation) world.spawn_dynamic_mesh(roadmark_triangles, roadmark_material, roadmark_segmentation) Sidewalks Sidewalks are represented using a set of oriented polygons with holes using carla.Sidewalk objects. In SUMMIT, sidewalks are automatically calculated as boundaries along road meshes: # Create sidewalk 1.5 meters from road's mesh. sidewalk = sumo_network_occupancy.create_sidewalk(1.5) # Create sidewalk's mesh for a sidewalk width of 3.0 meters. sidewalk_occupancy = sidewalk.create_occupancy_map(3.0) # Get mesh triangles, and defines sidewalk material and segmentation tag for sidewalk. sidewalk_triangles = sidewalk_occupancy.get_mesh_triangles() sidewalk_material = '/Game/Carla/Static/GenericMaterials/Ground/GroundWheatField_Mat' sidewalk_segmentation = 8 # Sidewalk (defined by CARLA). # Spawn sidewalk dynamically in simulator. world.spawn_dynamic_mesh(sidewalk_triangles, sidewalk_material, sidewalk_segmentation) Landmarks Landmarks can be loaded from the map's OSM file: landmark_occupancies = carla.Landmark.load(PATH_TO_OSM_FILE, sumo_network.offset) Note The sumo_network.offset argument applies an offset to each landmark equal to the offset applied to the SUMO network. This is required because the SUMO network itself is offset (by sumo_network.offset ) such that its bounds are aligned to the origin in the simulator. On the other hand, the landmarks maintain their global geographic position. Without applying the correct offset, the landmarks may end up at positions far away from the SUMO network. For each landmark, we can retrieve the ground, ceiling, and wall meshes to be spawned in the simulator: landmark_material = '/Game/Carla/Static/Buildings/aa_wall_mat' landmark_segmentation = 1 # Building (defined by CARLA) for landmark_occupancy in landmark_occupancies: # Get ground mesh, applying a vertical offset of 0 meters. ground_mesh_triangles = landmark_occupancy.get_mesh_triangles(0.0) # Get ceiling mesh triangles, with a vertical offset of 20.0 meters. ceiling_mesh_triangles = landmark_occupancy.get_mesh_triangles(20.0) # Get vertically rising mesh triangles, with a height of 20.0 meters. wall_mesh_triangles = landmark_occupancy.get_wall_mesh_triangles(20.0) # Spawn meshes dynamically in simulator. world.spawn_dynamic_mesh(ground_mesh_triangles, landmark_material, landmark_segmentation) world.spawn_dynamic_mesh(ceiling_mesh_triangles, landmark_material, landmark_segmentation) world.spawn_dynamic_mesh(wall_mesh_triangles, landmark_material, landmark_segmentation) The landmarks may sometime overlap with the roads and sidewalks. You may wish to do some preprocessing to remove these overlaps: sumo_network_occupancy = ... # Get road mesh. sidewalk_occupancy = ... # Get sidewalk mesh. landmark_occupancies = ... # Get landmark meshes. # Subtract road mesh and sidewalk mesh from landmark meshes. landmark_occupancies = [ l.difference(sumo_network_occupancy).difference(sidewalk_occupancy) for l in landmark_occupancies] # Filter empty landmark meshes. landmark_occupancies = [l for l in landmark_occupancies if not l.is_empty] Satellite/general imagery To spawn satellite imagery in SUMMIT, we provide a utility script at <summit_root>/PythonAPI/examples/spawn_imagery.py . It assumes that you have already downloadeded the satellite imagery . To use, run spawn_imagery.py --dataset <map_name> Note Spawning satellite imagery involves a tedious amount of work (such as looking up the map tile indices from geographical coordinates), and we highly recommend using the provided script which already deals with these efforts. The dynamic image tiles that SUMMIT expose to spawn satellite imagery can also be used to spawn any JPEG image in general. The below example spawns a an arbitrary image on a square region that is slanted along the z axis. with open(JPEG_PATH, 'rb') as f: # NOTE: Python 2 reads the file as a string instead of as an # array of bytes. ord(b) checks for this and converts accordingly. data = [ord(b) if isinstance(b, str) else b for b in f.read()] segmentation = 9 # Vegetation (defined by CARLA) bounds_min = carla.Vector3D(0, 0, -10) bounds_max = carla.Vector3D(100, 100, 10) world.spawn_dynamic_tile_mesh(bounds_min, bounds_max, data, segmentation) Saving and loading meshes You may wish to save meshes onto the disk, and reload them for future use, speeding up loading times by elimiating the unnecessary recomputations: # Saves mesh to the disk at SAVE_PATH. sumo_network_occupancy.save(SAVE_PATH) # Reload mesh from the disk. sumo_network_occupancy = carla.OccupancyMap.load(SAVE_PATH) # Spawn dynamically in simulator. world.spawn_dynamic_mesh(sumo_network_occupancy.get_mesh_triangles(), road_material, road_segmentation) This example works for any carla.OccupancyMap instance, not just for roads.","title":"Loading and spawning maps"},{"location":"tutorials/loading_and_spawning_maps/#connecting-to-the-simulator","text":"The steps to connect to the simulator derives from CARLA . A client object is created from which the world is received: client = carla.Client('localhost', 2000) world = client.get_world()","title":"Connecting to the simulator"},{"location":"tutorials/loading_and_spawning_maps/#roads-and-roadmarks","text":"Roads are represented using SUMO networks, which are loaded into memory via a SUMO network file: sumo_network = carla.SumoNetwork.load(PATH_TO_SUMO_NETWORK_FILE) The occupancy map (i.e. mesh) for the road can be produced by calling: sumo_network_occupancy = sumo_network.create_occupancy_map() If you required roadmarks (e.g. lane dividers), SUMMIT provides a fully automated way to generate the roadmarks' mesh: roadmark_occupancy = sumo_network.create_roadmark_occupancy_map() The road and roadmarks' meshes are then sent to the simulator and spawned dynamically: # Get mesh triangles, and defines material and segmentation tag for road. # Roadmarks' mesh is subtracted from the road's mesh to prevent flickering due to overlaps. road_triangles = sumo_network_occupancy.difference(roadmark_occupancy).get_mesh_triangles() road_material = '/Game/Carla/Static/GenericMaterials/Masters/LowComplexity/M_Road1' road_segmentation = 7 # Road (defined by CARLA). # Get mesh triangles, and defines material and segmentation tag for roadmarks. roadmark_triangles = roadmark_occupancy.get_mesh_triangles() roadmark_material = '/Game/Carla/Static/GenericMaterials/LaneMarking/M_MarkingLane_W' roadmark_segmentation = 6 # Road line (defined by CARLA). # Spawn road and roadmarks dynamically in simulator. world.spawn_dynamic_mesh(road_triangles, road_material, road_segmentation) world.spawn_dynamic_mesh(roadmark_triangles, roadmark_material, roadmark_segmentation)","title":"Roads and roadmarks"},{"location":"tutorials/loading_and_spawning_maps/#sidewalks","text":"Sidewalks are represented using a set of oriented polygons with holes using carla.Sidewalk objects. In SUMMIT, sidewalks are automatically calculated as boundaries along road meshes: # Create sidewalk 1.5 meters from road's mesh. sidewalk = sumo_network_occupancy.create_sidewalk(1.5) # Create sidewalk's mesh for a sidewalk width of 3.0 meters. sidewalk_occupancy = sidewalk.create_occupancy_map(3.0) # Get mesh triangles, and defines sidewalk material and segmentation tag for sidewalk. sidewalk_triangles = sidewalk_occupancy.get_mesh_triangles() sidewalk_material = '/Game/Carla/Static/GenericMaterials/Ground/GroundWheatField_Mat' sidewalk_segmentation = 8 # Sidewalk (defined by CARLA). # Spawn sidewalk dynamically in simulator. world.spawn_dynamic_mesh(sidewalk_triangles, sidewalk_material, sidewalk_segmentation)","title":"Sidewalks"},{"location":"tutorials/loading_and_spawning_maps/#landmarks","text":"Landmarks can be loaded from the map's OSM file: landmark_occupancies = carla.Landmark.load(PATH_TO_OSM_FILE, sumo_network.offset) Note The sumo_network.offset argument applies an offset to each landmark equal to the offset applied to the SUMO network. This is required because the SUMO network itself is offset (by sumo_network.offset ) such that its bounds are aligned to the origin in the simulator. On the other hand, the landmarks maintain their global geographic position. Without applying the correct offset, the landmarks may end up at positions far away from the SUMO network. For each landmark, we can retrieve the ground, ceiling, and wall meshes to be spawned in the simulator: landmark_material = '/Game/Carla/Static/Buildings/aa_wall_mat' landmark_segmentation = 1 # Building (defined by CARLA) for landmark_occupancy in landmark_occupancies: # Get ground mesh, applying a vertical offset of 0 meters. ground_mesh_triangles = landmark_occupancy.get_mesh_triangles(0.0) # Get ceiling mesh triangles, with a vertical offset of 20.0 meters. ceiling_mesh_triangles = landmark_occupancy.get_mesh_triangles(20.0) # Get vertically rising mesh triangles, with a height of 20.0 meters. wall_mesh_triangles = landmark_occupancy.get_wall_mesh_triangles(20.0) # Spawn meshes dynamically in simulator. world.spawn_dynamic_mesh(ground_mesh_triangles, landmark_material, landmark_segmentation) world.spawn_dynamic_mesh(ceiling_mesh_triangles, landmark_material, landmark_segmentation) world.spawn_dynamic_mesh(wall_mesh_triangles, landmark_material, landmark_segmentation) The landmarks may sometime overlap with the roads and sidewalks. You may wish to do some preprocessing to remove these overlaps: sumo_network_occupancy = ... # Get road mesh. sidewalk_occupancy = ... # Get sidewalk mesh. landmark_occupancies = ... # Get landmark meshes. # Subtract road mesh and sidewalk mesh from landmark meshes. landmark_occupancies = [ l.difference(sumo_network_occupancy).difference(sidewalk_occupancy) for l in landmark_occupancies] # Filter empty landmark meshes. landmark_occupancies = [l for l in landmark_occupancies if not l.is_empty]","title":"Landmarks"},{"location":"tutorials/loading_and_spawning_maps/#satellitegeneral-imagery","text":"To spawn satellite imagery in SUMMIT, we provide a utility script at <summit_root>/PythonAPI/examples/spawn_imagery.py . It assumes that you have already downloadeded the satellite imagery . To use, run spawn_imagery.py --dataset <map_name> Note Spawning satellite imagery involves a tedious amount of work (such as looking up the map tile indices from geographical coordinates), and we highly recommend using the provided script which already deals with these efforts. The dynamic image tiles that SUMMIT expose to spawn satellite imagery can also be used to spawn any JPEG image in general. The below example spawns a an arbitrary image on a square region that is slanted along the z axis. with open(JPEG_PATH, 'rb') as f: # NOTE: Python 2 reads the file as a string instead of as an # array of bytes. ord(b) checks for this and converts accordingly. data = [ord(b) if isinstance(b, str) else b for b in f.read()] segmentation = 9 # Vegetation (defined by CARLA) bounds_min = carla.Vector3D(0, 0, -10) bounds_max = carla.Vector3D(100, 100, 10) world.spawn_dynamic_tile_mesh(bounds_min, bounds_max, data, segmentation)","title":"Satellite/general imagery"},{"location":"tutorials/loading_and_spawning_maps/#saving-and-loading-meshes","text":"You may wish to save meshes onto the disk, and reload them for future use, speeding up loading times by elimiating the unnecessary recomputations: # Saves mesh to the disk at SAVE_PATH. sumo_network_occupancy.save(SAVE_PATH) # Reload mesh from the disk. sumo_network_occupancy = carla.OccupancyMap.load(SAVE_PATH) # Spawn dynamically in simulator. world.spawn_dynamic_mesh(sumo_network_occupancy.get_mesh_triangles(), road_material, road_segmentation) This example works for any carla.OccupancyMap instance, not just for roads.","title":"Saving and loading meshes"},{"location":"tutorials/preparing_maps/","text":"Important SUMMIT comes with a set of maps ready for use . This page is required only if you wish to use additional maps. Map data sources For a given map, SUMMIT requires both a corresponding OSM file and SUMO network, which provide the respective information: OSM file: Landmark data for spawning landmark objects. SUMO network: Road contexts, and geographical bounds for satellite imagery. Note that sidewalk information is not required at all, since SUMMIT automatically calculates the sidewalks as boundaries along roads. Note When working with real-world maps, the SUMO networks are typically generated from the OSM file. It is thus common that both the OSM file and SUMO network contains the same road information. The road information in the OSM file is simply unused after producing the SUMO network. While it is possible to use the road information in the OSM file directly, we choose to use a SUMO network as it provides a much more detailed representation to work with. In addition, SUMO comes with a flexible suite of tools to aid making fine adjustments to the SUMO networks. Important SUMMIT uses the convention of storing all map data inside the <summit-root>/Data/ folder. All data files pertaining to the same map should be given the same name with different extensions (e.g. meskel_square.osm , meskel_square.net.xml ). In addition, underscores should be in the file name to separate words in the map name. Obtaining OSM files To obtain high-quality real-world OSM files, we recommend using OpenStreetMap's database . Simply zoom into the are of interest, and export the map to <summit_root>/Data/<map_name>.osm , giving your map a reasonable name. You may wish to preprocess the OSM files using JOSM to remove road information unwanted from the simulation, such as service roads and footbridges. Note In SUMMIT, we do not impose any restrictions on the source of OSM files. You are free to use any OSM file, even those produced by yourself. Obtaining SUMO networks A SUMO network can be automatically obtained from an OSM file by using SUMO's NETCONVERT utility . This assumes that you have already setup the SUMO tools, as recommended in the requirements section . The SUMO network should then be stored at <summit_root>/Data/<map_name>.net.xml , where <map_name> follows from that of the OSM file. We provide an example script at <summit_root>/Scripts/osm2sumo.sh to convert an OSM file into a SUMO network. You are recommended to postprocess the SUMO network using SUMO's NETEDIT after the conversion. The conversion process is not perfect, and we highly recommend postprocessing the SUMO network to eliminate any ambiguities. Important Similar to the OSM files, you are free to use any source of SUMO networks, including those produce by yourself. There are some restrictions however: All lanes in SUMMIT are assumed to have a fixed width of 4.0 meters. Bounds for OSM file and corresponding SUMO network must line up, if not landmarks may spawn incorrectly. Note For SUMMIT's built in maps, we have done some postprocessing after the conversion, so it will be different from what is produced by simply calling the script. (Optional) Specifying simulation bounds For a given map, SUMMIT's traffic simulation script simulates traffic in a user defined bounds, specified in <summit_root>/Data/<map_name>.sim_bounds . We recommend specifying a suitable bounds if you are using a custom map, in order to use SUMMIT's built in traffic simulation script. Bounds in a .sim_bounds file are specified with the min_x,min_y on the first line, and max_x,max_y on the second line. For example, in <summit_root>/Data/meskel_square.sim_bounds : 350,300 550,500 These are in terms of CARLA coordinates. To find a suitable bounds for your map, you can use SUMO's NETEDIT tool as follows: Open the map's SUMO network in SUMO's NETEDIT tool. Find a suitable rectangular bound and note down the corner coordinates given by NETEDIT. These are in SUMO coordinates. Convert each SUMO coordinates into CARLA coordinates by swapping the x and y values. Take the minimum and maximum of x and y among the converted CARLA coordinates. (Optional) Caching map object meshes Often in SUMMIT, these mesh of map objects are calculated in order to spawn them dynamically in the simulator. The meshes can be calculated and saved beforehand to speed this process up. We provide a utility script at <summit_root>/Scripts/extract_meshes.py that calculates the meshes of various map objects for a given map, assuming that both the OSM file and SUMO network have been prepared. The meshes are stored at <summit_root>/Data/ with the respective names. As an example, running the following: extract_meshes.py --dataset meskel_square uses meskel_square.osm (OSM file) and meskel_square.net.xml (SUMO network) to produce the following files in <summit_root>/Data/ : meskel_square.network.wkt : Road mesh. meskel_square.roadmark.wkt : Roadmarks mesh. meskel_square.sidewalk.wkt : Sidewalk mesh. meskel_square.landmarks/*.landmark.wkt : Landmarks' meshes. (Optional) Downloading satellite imagery To download satellite imagery for your map, ensure that you have your map's SUMO network located at <summit_root>/Data/<map_name>.net.xml , so that SUMMIT can locate the geographic bounds. Then, run the following utility script: <summit_root>/Scripts/download_imagery.py --dataset <map_name> This downloads imagery that stored as tiles in <summit_root/Data/imagery/ in Slippy Map format .","title":"Preparing maps"},{"location":"tutorials/preparing_maps/#map-data-sources","text":"For a given map, SUMMIT requires both a corresponding OSM file and SUMO network, which provide the respective information: OSM file: Landmark data for spawning landmark objects. SUMO network: Road contexts, and geographical bounds for satellite imagery. Note that sidewalk information is not required at all, since SUMMIT automatically calculates the sidewalks as boundaries along roads. Note When working with real-world maps, the SUMO networks are typically generated from the OSM file. It is thus common that both the OSM file and SUMO network contains the same road information. The road information in the OSM file is simply unused after producing the SUMO network. While it is possible to use the road information in the OSM file directly, we choose to use a SUMO network as it provides a much more detailed representation to work with. In addition, SUMO comes with a flexible suite of tools to aid making fine adjustments to the SUMO networks. Important SUMMIT uses the convention of storing all map data inside the <summit-root>/Data/ folder. All data files pertaining to the same map should be given the same name with different extensions (e.g. meskel_square.osm , meskel_square.net.xml ). In addition, underscores should be in the file name to separate words in the map name.","title":"Map data sources"},{"location":"tutorials/preparing_maps/#obtaining-osm-files","text":"To obtain high-quality real-world OSM files, we recommend using OpenStreetMap's database . Simply zoom into the are of interest, and export the map to <summit_root>/Data/<map_name>.osm , giving your map a reasonable name. You may wish to preprocess the OSM files using JOSM to remove road information unwanted from the simulation, such as service roads and footbridges. Note In SUMMIT, we do not impose any restrictions on the source of OSM files. You are free to use any OSM file, even those produced by yourself.","title":"Obtaining OSM files"},{"location":"tutorials/preparing_maps/#obtaining-sumo-networks","text":"A SUMO network can be automatically obtained from an OSM file by using SUMO's NETCONVERT utility . This assumes that you have already setup the SUMO tools, as recommended in the requirements section . The SUMO network should then be stored at <summit_root>/Data/<map_name>.net.xml , where <map_name> follows from that of the OSM file. We provide an example script at <summit_root>/Scripts/osm2sumo.sh to convert an OSM file into a SUMO network. You are recommended to postprocess the SUMO network using SUMO's NETEDIT after the conversion. The conversion process is not perfect, and we highly recommend postprocessing the SUMO network to eliminate any ambiguities. Important Similar to the OSM files, you are free to use any source of SUMO networks, including those produce by yourself. There are some restrictions however: All lanes in SUMMIT are assumed to have a fixed width of 4.0 meters. Bounds for OSM file and corresponding SUMO network must line up, if not landmarks may spawn incorrectly. Note For SUMMIT's built in maps, we have done some postprocessing after the conversion, so it will be different from what is produced by simply calling the script.","title":"Obtaining SUMO networks"},{"location":"tutorials/preparing_maps/#optional-specifying-simulation-bounds","text":"For a given map, SUMMIT's traffic simulation script simulates traffic in a user defined bounds, specified in <summit_root>/Data/<map_name>.sim_bounds . We recommend specifying a suitable bounds if you are using a custom map, in order to use SUMMIT's built in traffic simulation script. Bounds in a .sim_bounds file are specified with the min_x,min_y on the first line, and max_x,max_y on the second line. For example, in <summit_root>/Data/meskel_square.sim_bounds : 350,300 550,500 These are in terms of CARLA coordinates. To find a suitable bounds for your map, you can use SUMO's NETEDIT tool as follows: Open the map's SUMO network in SUMO's NETEDIT tool. Find a suitable rectangular bound and note down the corner coordinates given by NETEDIT. These are in SUMO coordinates. Convert each SUMO coordinates into CARLA coordinates by swapping the x and y values. Take the minimum and maximum of x and y among the converted CARLA coordinates.","title":"(Optional) Specifying simulation bounds"},{"location":"tutorials/preparing_maps/#optional-caching-map-object-meshes","text":"Often in SUMMIT, these mesh of map objects are calculated in order to spawn them dynamically in the simulator. The meshes can be calculated and saved beforehand to speed this process up. We provide a utility script at <summit_root>/Scripts/extract_meshes.py that calculates the meshes of various map objects for a given map, assuming that both the OSM file and SUMO network have been prepared. The meshes are stored at <summit_root>/Data/ with the respective names. As an example, running the following: extract_meshes.py --dataset meskel_square uses meskel_square.osm (OSM file) and meskel_square.net.xml (SUMO network) to produce the following files in <summit_root>/Data/ : meskel_square.network.wkt : Road mesh. meskel_square.roadmark.wkt : Roadmarks mesh. meskel_square.sidewalk.wkt : Sidewalk mesh. meskel_square.landmarks/*.landmark.wkt : Landmarks' meshes.","title":"(Optional) Caching map object meshes"},{"location":"tutorials/preparing_maps/#optional-downloading-satellite-imagery","text":"To download satellite imagery for your map, ensure that you have your map's SUMO network located at <summit_root>/Data/<map_name>.net.xml , so that SUMMIT can locate the geographic bounds. Then, run the following utility script: <summit_root>/Scripts/download_imagery.py --dataset <map_name> This downloads imagery that stored as tiles in <summit_root/Data/imagery/ in Slippy Map format .","title":"(Optional) Downloading satellite imagery"},{"location":"tutorials/simulating_traffic/","text":"SUMMIT comes with a built in script to simulate traffic on a map, located at <summit_root>/PythonAPI/examples/gamma_crowd.py . It makes use of the recent GAMMA prediction model to simulate heterogeneous agent behavior with sophisticated and unregulated behaviors. To use the script, ensure that you have done the following: Specified simulation bounds . This is required, since the script needs to know where to bound the agents. It only spawns agents within the specified bounds, and actively remove agents that go out of bounds. Spawned the map objects . You can then call gamma_crowd.py --dataset <map_name> to simulate the traffic. A list of all arguments are available with the --help flag, and it is recommended to read through the options as you may find them useful for your needs.","title":"Simulating traffic"},{"location":"tutorials/using_roads_and_sidewalks/","text":"Spawning on roads On roads, route points, stored as carla.SumoNetworkRoutePoint objects, hold semantic information such the point's road, lane, and offset along lane. The SUMO network, stored as a carla.SumoNetwork , is used to traverse these route points spatially and topologically. One way to spawn points is to first lookup the route point on the road nearest to an arbitrary position. # Load SUMO network. sumo_network = carla.SumoNetwork.load(PATH_TO_SUMO_NETWORK_FILE) # Get arbitrary position. position = carla.Vector(100, 100) # Get nearest route point on SUMO network. route_point = sumo_network.get_nearest_route_point(position) Since the route point holds only semantic information and not the actual position, a translational query is required to determine the actual position to spawn the agent: # Get route point position. route_point_position = sumo_network.get_route_point_position(route_point) # Get route point transform route_point_transform = carla.Transform() route_point_transform.x = route_point_position.x route_point_transform.y = route_point_position.y route_point_transform.z = 0.5 # Spawn at a height of 0.5 meters. # Spawn actor. See CARLA's documentation. world.spawn_actor(BLUEPRINT, route_point_transform) Alternatively, you can use the carla.SegmentMap class to generate route points uniformly distributed along the lanes of the road. The carla.SegmentMap class is a data structure to work with line segments, optimized for uniform sampling of points over stored line segments. # Get segments of SUMO network. sumo_network_segments = sumo_network.create_segment_map() # Randmly pick spawn point. Note that this returns a position directly, not a route point. route_point_position = sumo_network_segments.rand_point() It is also possible to bound the spawn segments to a certain region, for example a rectangular bounding box: # Get segments of SUMO network. sumo_network_segments = sumo_network.create_segment_map() # Define bounding box. bounds_min = carla.Vector2D(-50, -50) bounds_max = carla.Vector2D(100, 300) bounds_occupancy = carla.OccupancyMap(bounds_min, bounds_max) # Calculate intersection of line segments with bounding box. spawn_segments = sumo_network_segments.intersection(bounds_occupancy) Note In SUMMIT, we strive to a support a wide range of geometric manipulations. As such, you can go all funky and do stuff like: # Arbitrary polygon. polygon = carla.OccupancyMap([carla.Vector2D(-50, -50), carla.Vector2D(-50, 100), carla.Vector2D(30, 200), carla.Vector2D(70, 70), carla.Vector2D(100, -70)]) # Arbitrary rectangle. rectangle1 = carla.OccupancyMap(carla.Vector2D(-30, -30), carla.Vector2D(200, 300)) # Another arbitrary rectangle. rectangle2 = carla.OccupancyMap(carla.Vector2D(-70, 30), carla.Vector2D(100, 200)) # Some combination of areas. spawn_occupancy = polygon.union(rectangle1).difference(rectangle2) # Crop line segments. spawn_segments = sumo_network_segments.intersection(spawn_occupancy) Navigation on roads On roads, the SUMO network can be used to traverse the route points spatially and topologically. The below example fetches the nearest route point given the agent's current position, and randomly selects from topologically possible next route points a set distance ahead. # Get 2D position of actor. location = actor.get_location() position2d = carla.Vector2D(location.x, location.y) # Lookup nearest route point. route_point = sumo_network.get_nearest_route_point(position2d) # Get all route points 1 meter ahead. next_route_points = sumo_network.get_next_route_points(route_point, 1.0) # Randomly select next route point. next_route_point = random.choice(next_route_points) Since the route point only holds semantic information and not the actual position, a translational query is required to determine the actual position: # Get next route point's position. position = sumo_network.get_route_point_position(next_route_point) which can then be used for required tasks, such as for feedback to some steering controller for vehicles. Spawning on sidewalks On sidewalks, things work very similar to roads. Sidewalks also have route points, stored as carla.SidewalkRoutePoint objects, which hold semantic information such as the point's polygon, segment, and offset along segment. The sidewalk, stored as a carla.Sidewalk , is used to traverse these route points spatially and topologically. One way to spawn points is to first lookup the route point on the road nearest to an arbitrary position. # Load SUMO network. sumo_network = carla.SumoNetwork.load(PATH_TO_SUMO_NETWORK_FILE) # Calculate sidewalk 1.5 meters from road's mesh. sumo_network_occupancy = sumo_network.create_occupancy_map() sidewalk = sumo_network_occupancy.create_sidewalk(1.5) # Get arbitrary position. position = carla.Vector(100, 100) # Get nearest route point on sidewalk. route_point = sidewalk.get_nearest_route_point(position) Since the route point holds only semantic information and not the actual position, a translational query is required to determine the actual position to spawn the agent: # Get route point position. route_point_position = sidewalk.get_route_point_position(route_point) # Get route point transform route_point_transform = carla.Transform() route_point_transform.x = route_point_position.x route_point_transform.y = route_point_position.y route_point_transform.z = 0.5 # Spawn at a height of 0.5 meters. # Spawn actor. See CARLA's documentation. world.spawn_actor(BLUEPRINT, route_point_transform) Alternatively, you can use the carla.SegmentMap class to generate route points uniformly distributed along the paths of the sidewalk. The carla.SegmentMap class is a data structure to work with line segments, optimized for uniform sampling of points over stored line segments. # Get segments of sidewalk. sidewalk_segments = sidewalk.create_segment_map() # Randmly pick spawn point. Note that this returns a position directly, not a route point. route_point_position = sidewalk_segments.rand_point() It is also possible to bound the spawn segments to a certain region, for example a rectangular bounding box: # Get segments of sidewalk. sidewalk_segments = sidewalk.create_segment_map() # Define bounding box. bounds_min = carla.Vector2D(-50, -50) bounds_max = carla.Vector2D(100, 300) bounds_occupancy = carla.OccupancyMap(bounds_min, bounds_max) # Calculate intersection of line segments with bounding box. spawn_segments = sidewalk_segments.intersection(bounds_occupancy) Note In SUMMIT, we strive to a support a wide range of geometric manipulations. As such, you can go all funky and do stuff like: # Arbitrary polygon. polygon = carla.OccupancyMap([carla.Vector2D(-50, -50), carla.Vector2D(-50, 100), carla.Vector2D(30, 200), carla.Vector2D(70, 70), carla.Vector2D(100, -70)]) # Arbitrary rectangle. rectangle1 = carla.OccupancyMap(carla.Vector2D(-30, -30), carla.Vector2D(200, 300)) # Another arbitrary rectangle. rectangle2 = carla.OccupancyMap(carla.Vector2D(-70, 30), carla.Vector2D(100, 200)) # Some combination of areas. spawn_occupancy = polygon.union(rectangle1).difference(rectangle2) # Crop line segments. spawn_segments = sidewalk_segments.intersection(spawn_occupancy) Navigating sidewalks On sidewalks, the sidewalk can be used to traverse the route points spatially and topologically. The below example fetches the nearest route point given the agent's current position, and selects the next route point a set distance anticlockwise along the route point's polygon. Note Sidewalks are structured using closed polygons, so there will always be exactly one next route point. Additionally, sidewalks in SUMMIT are always oriented anticlockwise, so that the next route point always goes anticlockwise along the current route point's polygon. # Get 2D position of actor. location = actor.get_location() position2d = carla.Vector2D(location.x, location.y) # Lookup nearest route point. route_point = sidewalk.get_nearest_route_point(position2d) # Get route point 1 meter anticlockwise along route point's polygon. next_route_point = sidewalk.get_next_route_point(route_point, 1.0) To get the next route point clockwise (instead of anticlockwise) along the current route point's polygon, use the get_previous_route_point method instead: # Get route point 1 meter clockwise along route point's polygon. next_route_point = sidewalk.get_previous_route_point(route_point, 1.0) You can also fetch the nearest point on an adjacent sidewalk polygon (i.e. on the other side of the road): # Get nearest adjacent route point, at most 50 meters away. # If such a route point exists, this returns None. a list of exactly one item. next_route_point = sidewalk.get_adjacent_route_point(route_point, 50.0) Since the route point only holds semantic information and not the actual position, a translational query is required to determine the actual position: # Get next route point's position. position = sidewalk.get_route_point_position(next_route_point) which can then be used for required tasks, such as for feedback to some heading controller for pedestrians.","title":"Using roads and sidewalks"},{"location":"tutorials/using_roads_and_sidewalks/#spawning-on-roads","text":"On roads, route points, stored as carla.SumoNetworkRoutePoint objects, hold semantic information such the point's road, lane, and offset along lane. The SUMO network, stored as a carla.SumoNetwork , is used to traverse these route points spatially and topologically. One way to spawn points is to first lookup the route point on the road nearest to an arbitrary position. # Load SUMO network. sumo_network = carla.SumoNetwork.load(PATH_TO_SUMO_NETWORK_FILE) # Get arbitrary position. position = carla.Vector(100, 100) # Get nearest route point on SUMO network. route_point = sumo_network.get_nearest_route_point(position) Since the route point holds only semantic information and not the actual position, a translational query is required to determine the actual position to spawn the agent: # Get route point position. route_point_position = sumo_network.get_route_point_position(route_point) # Get route point transform route_point_transform = carla.Transform() route_point_transform.x = route_point_position.x route_point_transform.y = route_point_position.y route_point_transform.z = 0.5 # Spawn at a height of 0.5 meters. # Spawn actor. See CARLA's documentation. world.spawn_actor(BLUEPRINT, route_point_transform) Alternatively, you can use the carla.SegmentMap class to generate route points uniformly distributed along the lanes of the road. The carla.SegmentMap class is a data structure to work with line segments, optimized for uniform sampling of points over stored line segments. # Get segments of SUMO network. sumo_network_segments = sumo_network.create_segment_map() # Randmly pick spawn point. Note that this returns a position directly, not a route point. route_point_position = sumo_network_segments.rand_point() It is also possible to bound the spawn segments to a certain region, for example a rectangular bounding box: # Get segments of SUMO network. sumo_network_segments = sumo_network.create_segment_map() # Define bounding box. bounds_min = carla.Vector2D(-50, -50) bounds_max = carla.Vector2D(100, 300) bounds_occupancy = carla.OccupancyMap(bounds_min, bounds_max) # Calculate intersection of line segments with bounding box. spawn_segments = sumo_network_segments.intersection(bounds_occupancy) Note In SUMMIT, we strive to a support a wide range of geometric manipulations. As such, you can go all funky and do stuff like: # Arbitrary polygon. polygon = carla.OccupancyMap([carla.Vector2D(-50, -50), carla.Vector2D(-50, 100), carla.Vector2D(30, 200), carla.Vector2D(70, 70), carla.Vector2D(100, -70)]) # Arbitrary rectangle. rectangle1 = carla.OccupancyMap(carla.Vector2D(-30, -30), carla.Vector2D(200, 300)) # Another arbitrary rectangle. rectangle2 = carla.OccupancyMap(carla.Vector2D(-70, 30), carla.Vector2D(100, 200)) # Some combination of areas. spawn_occupancy = polygon.union(rectangle1).difference(rectangle2) # Crop line segments. spawn_segments = sumo_network_segments.intersection(spawn_occupancy)","title":"Spawning on roads"},{"location":"tutorials/using_roads_and_sidewalks/#navigation-on-roads","text":"On roads, the SUMO network can be used to traverse the route points spatially and topologically. The below example fetches the nearest route point given the agent's current position, and randomly selects from topologically possible next route points a set distance ahead. # Get 2D position of actor. location = actor.get_location() position2d = carla.Vector2D(location.x, location.y) # Lookup nearest route point. route_point = sumo_network.get_nearest_route_point(position2d) # Get all route points 1 meter ahead. next_route_points = sumo_network.get_next_route_points(route_point, 1.0) # Randomly select next route point. next_route_point = random.choice(next_route_points) Since the route point only holds semantic information and not the actual position, a translational query is required to determine the actual position: # Get next route point's position. position = sumo_network.get_route_point_position(next_route_point) which can then be used for required tasks, such as for feedback to some steering controller for vehicles.","title":"Navigation on roads"},{"location":"tutorials/using_roads_and_sidewalks/#spawning-on-sidewalks","text":"On sidewalks, things work very similar to roads. Sidewalks also have route points, stored as carla.SidewalkRoutePoint objects, which hold semantic information such as the point's polygon, segment, and offset along segment. The sidewalk, stored as a carla.Sidewalk , is used to traverse these route points spatially and topologically. One way to spawn points is to first lookup the route point on the road nearest to an arbitrary position. # Load SUMO network. sumo_network = carla.SumoNetwork.load(PATH_TO_SUMO_NETWORK_FILE) # Calculate sidewalk 1.5 meters from road's mesh. sumo_network_occupancy = sumo_network.create_occupancy_map() sidewalk = sumo_network_occupancy.create_sidewalk(1.5) # Get arbitrary position. position = carla.Vector(100, 100) # Get nearest route point on sidewalk. route_point = sidewalk.get_nearest_route_point(position) Since the route point holds only semantic information and not the actual position, a translational query is required to determine the actual position to spawn the agent: # Get route point position. route_point_position = sidewalk.get_route_point_position(route_point) # Get route point transform route_point_transform = carla.Transform() route_point_transform.x = route_point_position.x route_point_transform.y = route_point_position.y route_point_transform.z = 0.5 # Spawn at a height of 0.5 meters. # Spawn actor. See CARLA's documentation. world.spawn_actor(BLUEPRINT, route_point_transform) Alternatively, you can use the carla.SegmentMap class to generate route points uniformly distributed along the paths of the sidewalk. The carla.SegmentMap class is a data structure to work with line segments, optimized for uniform sampling of points over stored line segments. # Get segments of sidewalk. sidewalk_segments = sidewalk.create_segment_map() # Randmly pick spawn point. Note that this returns a position directly, not a route point. route_point_position = sidewalk_segments.rand_point() It is also possible to bound the spawn segments to a certain region, for example a rectangular bounding box: # Get segments of sidewalk. sidewalk_segments = sidewalk.create_segment_map() # Define bounding box. bounds_min = carla.Vector2D(-50, -50) bounds_max = carla.Vector2D(100, 300) bounds_occupancy = carla.OccupancyMap(bounds_min, bounds_max) # Calculate intersection of line segments with bounding box. spawn_segments = sidewalk_segments.intersection(bounds_occupancy) Note In SUMMIT, we strive to a support a wide range of geometric manipulations. As such, you can go all funky and do stuff like: # Arbitrary polygon. polygon = carla.OccupancyMap([carla.Vector2D(-50, -50), carla.Vector2D(-50, 100), carla.Vector2D(30, 200), carla.Vector2D(70, 70), carla.Vector2D(100, -70)]) # Arbitrary rectangle. rectangle1 = carla.OccupancyMap(carla.Vector2D(-30, -30), carla.Vector2D(200, 300)) # Another arbitrary rectangle. rectangle2 = carla.OccupancyMap(carla.Vector2D(-70, 30), carla.Vector2D(100, 200)) # Some combination of areas. spawn_occupancy = polygon.union(rectangle1).difference(rectangle2) # Crop line segments. spawn_segments = sidewalk_segments.intersection(spawn_occupancy)","title":"Spawning on sidewalks"},{"location":"tutorials/using_roads_and_sidewalks/#navigating-sidewalks","text":"On sidewalks, the sidewalk can be used to traverse the route points spatially and topologically. The below example fetches the nearest route point given the agent's current position, and selects the next route point a set distance anticlockwise along the route point's polygon. Note Sidewalks are structured using closed polygons, so there will always be exactly one next route point. Additionally, sidewalks in SUMMIT are always oriented anticlockwise, so that the next route point always goes anticlockwise along the current route point's polygon. # Get 2D position of actor. location = actor.get_location() position2d = carla.Vector2D(location.x, location.y) # Lookup nearest route point. route_point = sidewalk.get_nearest_route_point(position2d) # Get route point 1 meter anticlockwise along route point's polygon. next_route_point = sidewalk.get_next_route_point(route_point, 1.0) To get the next route point clockwise (instead of anticlockwise) along the current route point's polygon, use the get_previous_route_point method instead: # Get route point 1 meter clockwise along route point's polygon. next_route_point = sidewalk.get_previous_route_point(route_point, 1.0) You can also fetch the nearest point on an adjacent sidewalk polygon (i.e. on the other side of the road): # Get nearest adjacent route point, at most 50 meters away. # If such a route point exists, this returns None. a list of exactly one item. next_route_point = sidewalk.get_adjacent_route_point(route_point, 50.0) Since the route point only holds semantic information and not the actual position, a translational query is required to determine the actual position: # Get next route point's position. position = sidewalk.get_route_point_position(next_route_point) which can then be used for required tasks, such as for feedback to some heading controller for pedestrians.","title":"Navigating sidewalks"}]}